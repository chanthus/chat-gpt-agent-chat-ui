<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <title>Ailo Support Assistant</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --sidebar-width: 280px;
            --sidebar-min-width: 200px;
            --sidebar-max-width: 500px;
        }

        /* Light mode colors */
        [data-theme="light"] {
            --primary-color: #0066ff;
            --hover-color: #0052cc;
            --text-primary: #1a1a1a;
            --text-secondary: #666;
            --border-color: #e5e7eb;
            --sidebar-bg: #f8f9fa;
            --sidebar-hover: #e9ecef;
            --main-bg: #ffffff;
            --user-msg-bg: #0066ff;
            --assistant-msg-bg: #f0f2f5;
            --unread-color: #ef4444;
            --input-bg: #f8f9fa;
            --code-bg: rgba(0, 0, 0, 0.05);
            --modal-bg: #ffffff;
        }

        /* Dark mode colors */
        [data-theme="dark"] {
            --primary-color: #4d94ff;
            --hover-color: #3d7fe6;
            --text-primary: #e5e7eb;
            --text-secondary: #9ca3af;
            --border-color: #374151;
            --sidebar-bg: #1f2937;
            --sidebar-hover: #374151;
            --main-bg: #111827;
            --user-msg-bg: #3b82f6;
            --assistant-msg-bg: #1f2937;
            --unread-color: #ef4444;
            --input-bg: #1f2937;
            --code-bg: rgba(255, 255, 255, 0.05);
            --modal-bg: #1f2937;
        }

        * {
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            margin: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--main-bg);
            color: var(--text-primary);
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            min-width: var(--sidebar-min-width);
            max-width: var(--sidebar-max-width);
            background: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            position: relative;
            transition: width 0.3s ease;
        }

        .sidebar.collapsed {
            width: 60px;
            min-width: 60px;
        }

        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 4px;
            height: 100%;
            cursor: col-resize;
            background: transparent;
            z-index: 10;
        }

        .sidebar-resize-handle:hover {
            background: var(--primary-color);
        }

        .sidebar-resize-handle.dragging {
            background: var(--primary-color);
        }

        .sidebar-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .sidebar-title {
            margin-bottom: 12px;
        }

        .sidebar-header h1 {
            font-size: 1.125rem;
            font-weight: 600;
            margin: 0;
            color: var(--text-primary);
        }

        .sidebar-toggle {
            background: var(--main-bg);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            padding: 6px;
            border-radius: 50%;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            right: -12px;
            top: 20px;
            width: 24px;
            height: 24px;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .sidebar-toggle:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.1);
        }

        .sidebar-toggle svg {
            width: 12px;
            height: 12px;
        }

        .sidebar.collapsed .sidebar-title h1,
        .sidebar.collapsed .search-container,
        .sidebar.collapsed .filter-container,
        .sidebar.collapsed .thread-name,
        .sidebar.collapsed .thread-actions,
        .sidebar.collapsed .unread-badge {
            display: none;
        }

        .sidebar.collapsed .sidebar-header {
            padding: 16px 8px;
        }

        .sidebar.collapsed .sidebar-toggle {
            right: -12px;
        }

        .sidebar.collapsed .thread-list {
            padding: 0 8px 80px 8px;
        }

        .sidebar.collapsed .thread-item {
            justify-content: center;
            padding: 10px 8px;
        }

        .sidebar.collapsed .new-thread-btn {
            left: 12px;
            width: 36px;
            height: 36px;
        }

        .search-container {
            position: relative;
            width: 100%;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--text-primary);
            font-size: 0.875rem;
            outline: none;
            transition: all 0.2s;
        }

        .search-input:focus {
            border-color: var(--primary-color);
            background: var(--main-bg);
        }

        .search-input::placeholder {
            color: var(--text-secondary);
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            color: var(--text-secondary);
            pointer-events: none;
        }

        /* Thread list container - takes remaining space */
        .thread-list-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Filter container */
        .filter-container {
            display: flex;
            gap: 8px;
            padding: 12px 24px;
            flex-shrink: 0;
            background: var(--sidebar-bg);
        }

        .filter-chip {
            padding: 6px 14px;
            border: 1px solid var(--border-color);
            border-radius: 16px;
            background: var(--main-bg);
            color: var(--text-secondary);
            font-size: 0.8125rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .filter-chip.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .filter-chip:hover:not(.active) {
            background: var(--sidebar-hover);
            color: var(--text-primary);
        }

        /* Thread List - scrollable area */
        .thread-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0 16px 80px 16px; /* Bottom padding for FAB */
        }

        .thread-list::-webkit-scrollbar {
            width: 6px;
        }

        .thread-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .thread-list::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }

        [data-theme="dark"] .thread-list::-webkit-scrollbar-thumb {
            background: #4b5563;
        }

        /* Floating Action Button */
        .new-thread-btn {
            position: absolute;
            bottom: 24px;
            left: 24px;
            width: 56px;
            height: 56px;
            padding: 0;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10;
        }

        .new-thread-btn:hover {
            background: var(--hover-color);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .new-thread-btn:active {
            transform: scale(0.95);
        }

        .new-thread-btn svg {
            width: 24px;
            height: 24px;
        }

        /* Tooltip */
        .new-thread-btn::after {
            content: 'New conversation';
            position: absolute;
            right: auto;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 8px;
            bottom: auto;
            margin-bottom: 0;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.75rem;
            font-weight: 400;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .new-thread-btn:hover::after {
            opacity: 1;
        }

        /* Remove old sidebar footer */
        .sidebar-footer {
            display: none;
        }

        .thread-item {
            padding: 10px 12px;
            margin-bottom: 2px;
            cursor: pointer;
            display: flex;
            align-items: center;
            border-radius: 8px;
            transition: all 0.2s;
            position: relative;
            group: true;
        }

        .thread-item:hover {
            background: var(--sidebar-hover);
        }

        .thread-item.active {
            background: #e3f2fd;
            color: var(--primary-color);
        }

        .thread-name {
            flex: 1;
            font-size: 0.875rem;
            font-weight: 450;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .thread-name.generating {
            color: var(--text-secondary);
            font-style: italic;
        }

        .thread-name-input {
            flex: 1;
            background: white;
            border: 2px solid var(--primary-color);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.875rem;
            font-family: inherit;
            outline: none;
        }

        .thread-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .thread-item:hover .thread-actions {
            opacity: 1;
        }

        .thread-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .thread-btn:hover {
            background: rgba(0, 0, 0, 0.08);
            color: var(--text-primary);
        }

        [data-theme="dark"] .thread-btn:hover {
            background: var(--primary-color);
            color: #ffffff;
        }

        .thread-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Unread badge */
        .unread-badge {
            background: var(--unread-color);
            color: white;
            border-radius: 10px;
            padding: 1px 8px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 8px;
            min-width: 20px;
            text-align: center;
        }

        /* Awaiting response indicator */
        .awaiting-response {
            width: 8px;
            height: 8px;
            background: var(--primary-color);
            border-radius: 50%;
            margin-left: 8px;
            flex-shrink: 0;
            opacity: 0.7;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.7;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.1);
            }
            100% {
                opacity: 0.7;
                transform: scale(1);
            }
        }

        .thread-item.active .awaiting-response {
            background: var(--primary-color);
            opacity: 0.8;
        }

        /* Main Area */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--main-bg);
        }

        /* Chat Header */
        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 65px;
            padding: 0 24px;
            border-bottom: 1px solid var(--border-color);
            background: var(--main-bg);
        }

        #currentThreadLabel {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            padding: 10px;
            border: 1px solid var(--border-color);
            background: var(--main-bg);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            position: relative;
        }

        /* Dark mode toggle */
        .theme-toggle {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            background: var(--main-bg);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .theme-toggle:hover {
            background: var(--sidebar-hover);
            border-color: #d1d5db;
        }

        .theme-toggle svg {
            width: 16px;
            height: 16px;
        }

        .header-btn:hover {
            background: var(--sidebar-bg);
            border-color: #d1d5db;
        }

        .header-btn.danger {
            color: var(--unread-color);
        }

        .header-btn.danger:hover {
            background: #fee;
            border-color: var(--unread-color);
        }

        .header-btn svg {
            width: 18px;
            height: 18px;
        }

        /* Tooltip for header buttons */
        .header-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 8px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.75rem;
            font-weight: 400;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        .header-btn:hover::after {
            opacity: 1;
        }

        /* Special positioning for the clear button (last button) */
        .header-btn:last-child::after {
            left: auto;
            right: 0;
            transform: none;
        }

        .header-btn::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 2px;
            border: 4px solid transparent;
            border-bottom-color: rgba(0, 0, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .header-btn:hover::before {
            opacity: 1;
        }

        /* Arrow positioning for the clear button */
        .header-btn:last-child::before {
            left: auto;
            right: 16px;
            transform: none;
        }

        /* Chat Area */
        #chat {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            background: var(--main-bg);
        }

        #chat::-webkit-scrollbar {
            width: 8px;
        }

        #chat::-webkit-scrollbar-track {
            background: transparent;
        }

        #chat::-webkit-scrollbar-thumb {
            background: #e5e7eb;
            border-radius: 4px;
        }

        /* Messages */
        .message {
            margin-bottom: 16px;
            display: flex;
            align-items: flex-start;
            max-width: 70%;
            position: relative;
            group: true;
        }

        .message.new-message {
            animation: messageSlide 0.3s ease-out;
        }

        .message.highlighted-message {
            animation: messageHighlight 3s ease-out;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes messageHighlight {
            0% {
                background-color: rgba(255, 235, 59, 0.3);
                transform: scale(1.02);
            }
            20% {
                background-color: rgba(255, 235, 59, 0.2);
            }
            100% {
                background-color: transparent;
                transform: scale(1);
            }
        }

        .message.user {
            margin-left: auto;
            flex-direction: row-reverse;
        }

        .message-content {
            padding: 12px 16px;
            border-radius: 16px;
            position: relative;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        /* Copy button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            border-radius: 6px;
            padding: 6px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .copy-btn:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: scale(1.1);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
            color: var(--text-primary);
        }

        .message:hover .copy-btn {
            opacity: 1;
        }

        .user .copy-btn {
            background: rgba(255, 255, 255, 0.2);
        }

        .user .copy-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .user .copy-btn svg {
            color: white;
        }

        /* Copy success animation */
        .copy-btn.copied {
            background: #10b981 !important;
            transform: scale(1.2);
        }

        .copy-btn.copied svg {
            color: white !important;
        }

        .user .message-content {
            background: var(--user-msg-bg);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .assistant .message-content {
            background: var(--assistant-msg-bg);
            color: var(--text-primary);
            border-bottom-left-radius: 4px;
        }

        .message-content div {
            white-space: normal;
            overflow-wrap: anywhere;
            font-size: 0.9375rem;
            line-height: 1.5;
        }

        /* Markdown styling */
        .assistant .message-content pre {
            background: #1a1a1a;
            color: #e5e7eb;
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 8px 0;
        }

        .assistant .message-content code {
            background: var(--code-bg);
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        .assistant .message-content pre code {
            background: none;
            padding: 0;
        }

        .timestamp {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 4px;
            padding: 0 16px;
            white-space: nowrap;
            cursor: pointer;
            position: relative;
        }

        /* Custom tooltip for timestamps */
        .timestamp::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-size: 0.75rem;
            font-weight: 400;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 300px;
        }

        .timestamp:hover::after {
            opacity: 1;
        }

        .user .timestamp {
            text-align: right;
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 12px 16px;
            background: var(--assistant-msg-bg);
            border-radius: 16px;
            border-bottom-left-radius: 4px;
            width: fit-content;
            margin-bottom: 16px;
        }

        .typing-indicator::after {
            content: '';
            animation: typingDots 1.4s infinite;
        }

        @keyframes typingDots {
            0%, 60%, 100% { content: ''; }
            20% { content: '.'; }
            40% { content: '..'; }
            80% { content: '...'; }
        }

        /* Unread Divider */
        .unread-divider {
            display: flex;
            align-items: center;
            margin: 24px 0;
            color: var(--unread-color);
            font-size: 0.8125rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .unread-divider::before,
        .unread-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--unread-color);
            opacity: 0.3;
        }

        .unread-divider::before {
            margin-right: 12px;
        }

        .unread-divider::after {
            margin-left: 12px;
        }

        /* Input Area */
        #input-container {
            display: flex;
            height: 81px;
            padding: 16px 24px;
            background: var(--main-bg);
            border-top: 1px solid var(--border-color);
            gap: 12px;
            align-items: center;
            position: relative;
        }

        /* Inline completion styles */
        .input-wrapper {
            position: relative;
            flex: 1;
        }

        #input-ghost {
            position: absolute;
            top: 1px;
            left: 16px;
            height: calc(100% - 2px);
            font-size: 0.9375rem;
            font-family: inherit;
            color: transparent;
            background: transparent;
            pointer-events: none;
            white-space: nowrap;
            overflow: hidden;
            z-index: 3;
            line-height: 1.5;
            padding: 12px 0;
            margin: 0;
            border: none;
            display: flex;
            align-items: center;
            box-sizing: border-box;
        }

        .ghost-prefix {
            color: transparent;
            visibility: hidden;
        }

        .ghost-text {
            color: var(--text-secondary);
            opacity: 0.8;
            background: rgba(0, 102, 255, 0.1);
            padding: 0 2px;
            border-radius: 3px;
        }

        .completion-hint {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            color: var(--text-secondary);
            background: var(--input-bg);
            padding: 2px 8px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 2;
        }

        .input-wrapper:hover .completion-hint,
        .input-wrapper.has-completion .completion-hint {
            opacity: 1;
        }

        #input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: 24px;
            font-size: 0.9375rem;
            outline: none;
            transition: all 0.2s;
            background: var(--input-bg);
            color: var(--text-primary);
            position: relative;
            z-index: 2;
        }

        #input:focus {
            border-color: var(--primary-color);
            background: var(--main-bg);
        }

        #input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #send {
            padding: 12px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            position: relative;
        }

        #send:hover:not(:disabled) {
            background: var(--hover-color);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
        }

        #send:active:not(:disabled) {
            transform: scale(0.95);
        }

        #send:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #send svg {
            width: 20px;
            height: 20px;
            transition: transform 0.2s;
            display: block;
        }

        #send .spinner {
            flex-shrink: 0;
        }

        #send:hover:not(:disabled) svg {
            transform: translateX(1px);
        }

        /* Send button tooltip */
        #send::after {
            content: 'Send (Enter)';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.75rem;
            font-weight: 400;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        #send:hover::after {
            opacity: 1;
        }

        #send:disabled::after {
            content: 'Please wait...';
        }

        /* Spinner animation */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: block;
            margin: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }



        /* Settings Modal */
        .modal-dialog {
            max-width: 600px;
        }

        .modal-content {
            border: none;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            background: var(--modal-bg);
            color: var(--text-primary);
        }

        .modal-header {
            border-bottom: 1px solid var(--border-color);
            padding: 20px 24px;
            background: var(--modal-bg);
        }

        .modal-title {
            font-weight: 600;
            font-size: 1.125rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-title svg {
            width: 20px;
            height: 20px;
            color: var(--primary-color);
        }

        .modal-body {
            padding: 24px;
        }

        .settings-group {
            margin-bottom: 20px;
            padding-bottom: 12px;
            position: relative;
        }



        .settings-group:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .group-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 20px 0 16px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.8;
            text-align: center;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-group:first-child .group-title {
            margin-top: 0;
        }

        .group-title::before,
        .group-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-color);
        }

        .group-title::before {
            margin-right: 16px;
        }

        .group-title::after {
            margin-left: 16px;
        }

        .setting-item {
            margin-bottom: 20px;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--text-primary);
            margin-bottom: 6px;
            display: block;
        }

        .setting-description {
            font-size: 0.8125rem;
            color: var(--text-secondary);
            margin-top: 4px;
            line-height: 1.4;
        }

        .form-control {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 0.875rem;
            transition: all 0.2s;
            background: var(--input-bg);
            color: var(--text-primary);
            width: 100%;
        }

        .form-control:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);
            background: var(--main-bg);
            outline: none;
        }

        .form-control[type="password"] {
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }

        .checkbox-setting {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--input-bg);
            transition: all 0.2s;
            cursor: pointer;
        }

        .checkbox-setting:hover {
            background: var(--sidebar-hover);
            border-color: var(--primary-color);
        }

        .checkbox-setting input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
            accent-color: var(--primary-color);
            flex-shrink: 0;
            align-self: center;
        }

        .checkbox-content {
            flex: 1;
        }

        .checkbox-label {
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--text-primary);
            cursor: pointer;
            margin-bottom: 2px;
            display: block;
        }

        .checkbox-description {
            font-size: 0.8125rem;
            color: var(--text-secondary);
            line-height: 1.3;
        }

        .select-wrapper {
            position: relative;
        }

        .select-wrapper::after {
            content: '';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid var(--text-secondary);
            pointer-events: none;
        }

        .form-control.select {
            appearance: none;
            background-image: none;
            padding-right: 32px;
        }

        .modal-footer {
            border-top: 1px solid var(--border-color);
            padding: 16px 24px;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .btn-secondary {
            background: var(--border-color);
            color: var(--text-secondary);
        }

        .btn-secondary:hover {
            background: var(--text-secondary);
            color: var(--main-bg);
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: var(--hover-color);
        }

        .btn-close {
            filter: var(--btn-close-filter, none);
        }

        [data-theme="dark"] .btn-close {
            filter: invert(1);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar { width: 80px; }
            .sidebar-header h1 { display: none; }
            .thread-name { display: none; }
            .unread-badge { position: absolute; top: 4px; right: 4px; }
            .search-container { display: none; }
            .filter-container { display: none; }
            #chat { padding: 16px; }
            .message { max-width: 85%; }
        }

        /* Search Results */
        .search-results {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 8px;
            background: var(--modal-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2);
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: var(--sidebar-hover);
        }

        .search-result-item.selected {
            background: var(--primary-color);
            color: white;
        }

        .search-result-item.selected .search-result-thread {
            color: rgba(255, 255, 255, 0.9);
        }

        .search-result-item.selected .search-result-meta {
            color: rgba(255, 255, 255, 0.7);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-thread {
            font-size: 0.75rem;
            color: var(--primary-color);
            font-weight: 500;
            margin-bottom: 4px;
        }

        .search-result-text {
            font-size: 0.875rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .search-result-text mark {
            background: rgba(255, 235, 59, 0.3);
            color: inherit;
            padding: 1px 2px;
            border-radius: 2px;
        }

        .search-result-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 4px;
            cursor: pointer;
            position: relative;
        }

        /* Custom tooltip for search result meta */
        .search-result-meta::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-size: 0.75rem;
            font-weight: 400;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 300px;
        }

        .search-result-meta:hover::after {
            opacity: 1;
        }

        .no-results {
            padding: 24px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .empty-state {
            padding: 24px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .welcome-message {
            text-align: center;
            padding: 60px 40px;
            color: var(--text-secondary);
        }

        .welcome-message h2 {
            color: var(--text-primary);
            margin-bottom: 16px;
            font-size: 1.5rem;
        }

        /* Auto-completion styles */
        .autocomplete-suggestions {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--modal-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            max-height: 280px;
            overflow: hidden;
            display: none;
            z-index: 1000;
            box-shadow: 0 20px 40px -8px rgba(0, 0, 0, 0.25);
            margin-bottom: 12px;
            backdrop-filter: blur(10px);
            animation: slideUp 0.2s ease-out;
        }

        .autocomplete-suggestions.active {
            display: block;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .suggestions-header {
            padding: 12px 16px 8px 16px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, var(--primary-color), var(--hover-color));
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .suggestions-header svg {
            width: 14px;
            height: 14px;
            opacity: 0.9;
        }

        .suggestions-list {
            max-height: 220px;
            overflow-y: auto;
            padding: 4px 0;
        }

        .suggestions-list::-webkit-scrollbar {
            width: 6px;
        }

        .suggestions-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .suggestions-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .suggestion-item {
            padding: 14px 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 0.875rem;
            line-height: 1.4;
            position: relative;
            margin: 2px 8px;
            border-radius: 10px;
        }

        .suggestion-item:hover {
            background: var(--sidebar-hover);
            transform: translateX(2px);
        }

        .suggestion-item.selected {
            background: linear-gradient(135deg, var(--primary-color), var(--hover-color));
            color: white;
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
        }

        .suggestion-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .suggestion-text {
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .suggestion-prefix {
            background: rgba(0, 102, 255, 0.15);
            color: var(--primary-color);
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 0.8125rem;
            border: 1px solid rgba(0, 102, 255, 0.2);
        }

        .suggestion-completion {
            color: var(--text-primary);
            font-weight: 400;
            margin-left: 2px;
        }

        .suggestion-item.selected .suggestion-prefix {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .suggestion-item.selected .suggestion-completion {
            color: white;
            font-weight: 500;
        }

        .suggestion-meta {
            font-size: 0.7rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 4px;
            opacity: 0.8;
        }

        .suggestion-meta svg {
            width: 12px;
            height: 12px;
        }

        .suggestion-item.selected .suggestion-meta {
            color: rgba(255, 255, 255, 0.8);
        }

        .suggestion-item:hover .suggestion-meta {
            opacity: 1;
        }

        .autocomplete-loading {
            padding: 20px 16px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .autocomplete-loading .spinner {
            width: 18px;
            height: 18px;
            border-width: 2px;
            border-color: var(--primary-color) transparent var(--primary-color) transparent;
        }

        .autocomplete-empty {
            padding: 20px 16px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-style: italic;
        }

        /* Keyboard shortcut hint */
        .suggestion-shortcut {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.7rem;
            color: var(--text-secondary);
            background: var(--input-bg);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .suggestion-item:hover .suggestion-shortcut,
        .suggestion-item.selected .suggestion-shortcut {
            opacity: 1;
        }

        .suggestion-item.selected .suggestion-shortcut {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.9);
        }
    </style>
</head>
<body data-theme="dark">
<div class="app-container">
    <div class="sidebar">
        <div class="sidebar-resize-handle"></div>
        <button class="sidebar-toggle" id="sidebarToggle" title="Toggle sidebar">
            <svg class="collapse-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clip-rule="evenodd" />
            </svg>
            <svg class="expand-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clip-rule="evenodd" />
            </svg>
        </button>
        <div class="sidebar-header">
            <div class="sidebar-title">
                <h1>Ailo Support Assistant</h1>
            </div>
            <div class="search-container">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                </svg>
                <input type="text" id="searchInput" class="search-input" placeholder="Search messages...">
                <div id="searchResults" class="search-results"></div>
            </div>
        </div>
        <div class="thread-list-container">
            <div class="filter-container">
                <div class="filter-chip active" data-filter="all">All</div>
                <div class="filter-chip" data-filter="unread">Unread</div>
            </div>
            <div class="thread-list" id="threadList"></div>
        </div>
        <button id="newThreadBtn" class="new-thread-btn" title="New conversation">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z" />
            </svg>
        </button>
    </div>
    <div class="main-area">
        <div class="chat-header">
            <span id="currentThreadLabel"></span>
            <div class="header-actions">
                <button id="themeToggle" class="theme-toggle" title="Toggle theme">
                    <svg class="sun-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10 2a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 2zM10 15a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 15zM10 7a3 3 0 100 6 3 3 0 000-6zM15.657 5.404a.75.75 0 10-1.06-1.06l-1.061 1.06a.75.75 0 001.06 1.061l1.06-1.06zM6.464 14.596a.75.75 0 10-1.06-1.06l-1.061 1.06a.75.75 0 001.06 1.061l1.06-1.06zM18 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0118 10zM5 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 015 10zM14.596 15.657a.75.75 0 001.06-1.06l-1.06-1.061a.75.75 0 10-1.061 1.06l1.06 1.06zM5.404 6.464a.75.75 0 001.06-1.06l-1.06-1.061a.75.75 0 10-1.061 1.06l1.06 1.06z"/>
                    </svg>
                    <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.455 2.004a.75.75 0 01.26.77 7 7 0 009.958 7.967.75.75 0 011.067.853A8.5 8.5 0 116.647 1.921a.75.75 0 01.808.083z" clip-rule="evenodd"/>
                    </svg>
                </button>
                <button id="settingsBtn" class="header-btn" data-tooltip="Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.84 1.804A1 1 0 018.82 1h2.36a1 1 0 01.98.804l.331 1.652a6.993 6.993 0 011.929 1.115l1.598-.54a1 1 0 011.186.447l1.18 2.044a1 1 0 01-.205 1.251l-1.267 1.113a7.047 7.047 0 010 2.228l1.267 1.113a1 1 0 01.205 1.251l-1.18 2.044a1 1 0 01-1.186.447l-1.598-.54a6.993 6.993 0 01-1.929 1.115l-.33 1.652a1 1 0 01-.98.804H8.82a1 1 0 01-.98-.804l-.331-1.652a6.993 6.993 0 01-1.929-1.115l-1.598.54a1 1 0 01-1.186-.447l-1.18-2.044a1 1 0 01.205-1.251l1.267-1.114a7.05 7.05 0 010-2.227L1.821 7.773a1 1 0 01-.205-1.251l1.18-2.044a1 1 0 011.186-.447l1.598.54A6.993 6.993 0 017.51 3.456l.33-1.652zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                    </svg>
                </button>
                <button id="reset" class="header-btn danger" data-tooltip="Clear conversation history">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.584.176-2.365.298a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193V3.75A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>
        <div id="chat"></div>
        <div id="input-container">
            <div class="input-wrapper">
                <div class="autocomplete-suggestions" id="autocompleteSuggestions"></div>
                <div id="input-ghost"></div>
                <input type="text" id="input" placeholder="Message Assistant..." />
                <div class="completion-hint">Tab to complete</div>
            </div>
            <button id="send">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M3.105 2.289a.75.75 0 00-.826.95l1.414 4.925A1.5 1.5 0 005.135 9.25h6.115a.75.75 0 010 1.5H5.135a1.5 1.5 0 00-1.442 1.086l-1.414 4.926a.75.75 0 00.826.95 28.896 28.896 0 0015.293-7.154.75.75 0 000-1.115A28.896 28.896 0 003.105 2.289z"/>
                </svg>
            </button>
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="settingsModalLabel">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.84 1.804A1 1 0 018.82 1h2.36a1 1 0 01.98.804l.331 1.652a6.993 6.993 0 011.929 1.115l1.598-.54a1 1 0 011.186.447l1.18 2.044a1 1 0 01-.205 1.251l-1.267 1.113a7.047 7.047 0 010 2.228l1.267 1.113a1 1 0 01.205 1.251l-1.18 2.044a1 1 0 01-1.186.447l-1.598-.54a6.993 6.993 0 01-1.929 1.115l-.33 1.652a1 1 0 01-.98.804H8.82a1 1 0 01-.98-.804l-.331-1.652a6.993 6.993 0 01-1.929-1.115l-1.598.54a1 1 0 01-1.186-.447l-1.18-2.044a1 1 0 01.205-1.251l1.267-1.114a7.05 7.05 0 010-2.227L1.821 7.773a1 1 0 01-.205-1.251l1.18-2.044a1 1 0 011.186-.447l1.598.54A6.993 6.993 0 017.51 3.456l.33-1.652zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                    </svg>
                    Settings
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- API Configuration -->
                <div class="settings-group">
                    <div class="group-title">API Configuration</div>
                    
                    <div class="setting-item">
                        <label for="apiKeyInput" class="setting-label">OpenAI API Key</label>
                        <input type="password" class="form-control" id="apiKeyInput" placeholder="sk-proj-...">
                        <div class="setting-description">Your OpenAI API key for accessing GPT models. Keep this secure.</div>
                    </div>
                    
                    <div class="setting-item">
                        <label for="assistantIdInput" class="setting-label">Assistant ID</label>
                        <input type="text" class="form-control" id="assistantIdInput" placeholder="asst_...">
                        <div class="setting-description">The ID of your OpenAI Assistant that will handle conversations.</div>
                    </div>
                </div>

                <!-- AI Features -->
                <div class="settings-group">
                    <div class="group-title">AI Features</div>
                    
                    <div class="setting-item">
                        <label for="autoCompleteModelSelect" class="setting-label">Auto-completion Model</label>
                        <div class="select-wrapper">
                            <select class="form-control select" id="autoCompleteModelSelect">
                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Fast & Cost-effective)</option>
                                <option value="gpt-4o-mini">GPT-4o Mini (Fastest GPT-4)</option>
                                <option value="gpt-4o">GPT-4o (Latest & Best)</option>
                                <option value="gpt-4.1">GPT-4.1 (Advanced)</option>
                                <option value="gpt-4.1-mini">GPT-4.1 Mini (Efficient)</option>
                                <option value="gpt-4.1-nano">GPT-4.1 Nano (Ultra-fast)</option>
                            </select>
                        </div>
                        <div class="setting-description">Choose the AI model for message auto-completion.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="checkbox-setting">
                            <input type="checkbox" id="autoCompleteCheckbox">
                            <div class="checkbox-content">
                                <label class="checkbox-label" for="autoCompleteCheckbox">Enable Auto-completion</label>
                                <div class="checkbox-description">Get AI suggestions as you type. Press Tab or  to accept.</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="checkbox-setting">
                            <input type="checkbox" id="autoNamingCheckbox">
                            <div class="checkbox-content">
                                <label class="checkbox-label" for="autoNamingCheckbox">Auto-generate Thread Names</label>
                                <div class="checkbox-description">Automatically create descriptive names for conversations.</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Display Preferences -->
                <div class="settings-group">
                    <div class="group-title">Display Preferences</div>
                    
                    <div class="setting-item">
                        <div class="checkbox-setting">
                            <input type="checkbox" id="renderMarkdownCheckbox">
                            <div class="checkbox-content">
                                <label class="checkbox-label" for="renderMarkdownCheckbox">Render Markdown</label>
                                <div class="checkbox-description">Display messages with rich formatting (bold, italic, code blocks, etc.).</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="checkbox-setting">
                            <input type="checkbox" id="notificationsCheckbox">
                            <div class="checkbox-content">
                                <label class="checkbox-label" for="notificationsCheckbox">Browser Notifications</label>
                                <div class="checkbox-description">Show notifications for new messages when tab is not active.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" id="saveSettings" class="btn btn-primary">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<script>
  // Search and filter functionality
  let currentFilter = 'all';
  let searchQuery = '';
  let searchTimeout = null;
  let selectedSearchIndex = -1;

  function performSearch(query) {
    const results = [];
    if (query.length < 2) return results;

    const lowerQuery = query.toLowerCase();

    for (const threadId of threadOrder) {
      const thread = threads[threadId];
      if (!thread) continue;

      const threadResults = [];

      // Search in thread name
      if (thread.displayName.toLowerCase().includes(lowerQuery)) {
        threadResults.push({
          threadId,
          threadName: thread.displayName,
          text: thread.displayName,
          sender: 'thread',
          timestamp: null,
          isThreadName: true,
          messageIndex: -1
        });
      }

      // Search in messages
      for (let i = 0; i < (thread.chatHistory || []).length; i++) {
        const msg = thread.chatHistory[i];
        const cleanText = msg.text.replace(/\d+:\d+[^]+/g, '');
        if (cleanText.toLowerCase().includes(lowerQuery)) {
          threadResults.push({
            threadId,
            threadName: thread.displayName,
            text: cleanText,
            sender: msg.sender,
            timestamp: msg.timestamp,
            messageIndex: i
          });
        }
      }

      results.push(...threadResults);
    }

    return results.slice(0, 20); // Limit to 20 results
  }

  function highlightText(text, query) {
    if (!query) return text;
    const regex = new RegExp(`(${query})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }

  function displaySearchResults(results, query) {
    const container = document.getElementById('searchResults');
    selectedSearchIndex = -1; // Reset selection

    if (results.length === 0 && query.length >= 2) {
      container.innerHTML = '<div class="no-results">No results found</div>';
      container.classList.add('active');
      return;
    }

    if (results.length === 0) {
      container.classList.remove('active');
      return;
    }

    container.innerHTML = results.map((result, index) => {
      const truncatedText = result.text.length > 100 ?
        result.text.substring(0, 100) + '...' :
        result.text;

      const highlightedText = highlightText(truncatedText, query);
      const timeStr = result.timestamp ?
        new Date(result.timestamp).toLocaleString([], {
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        }) : '';
      
      const fullTimeStr = result.timestamp ?
        new Date(result.timestamp).toLocaleString([], { 
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric', 
          hour: 'numeric', 
          minute: '2-digit', 
          second: '2-digit',
          hour12: true 
        }) : '';
      


      return `
        <div class="search-result-item" data-thread-id="${result.threadId}" data-index="${index}" data-message-index="${result.messageIndex || -1}">
          <div class="search-result-thread">${result.threadName}</div>
          <div class="search-result-text">${highlightedText}</div>
          ${timeStr ? `<div class="search-result-meta" data-tooltip="${fullTimeStr}" title="${fullTimeStr}">${result.sender}  ${timeStr}</div>` : ''}
        </div>
      `;
    }).join('');

    container.classList.add('active');

    // Add click handlers
    container.querySelectorAll('.search-result-item').forEach(item => {
      item.onclick = () => {
        selectSearchResult(item);
      };
    });
  }

  function selectSearchResult(item) {
    const threadId = item.getAttribute('data-thread-id');
    const messageIndex = parseInt(item.getAttribute('data-message-index'));
    
    currentThreadId = threadId;
    localStorage.setItem('currentThreadId', currentThreadId);
    searchQuery = '';
    document.getElementById('searchInput').value = '';
    document.getElementById('searchResults').classList.remove('active');
    selectedSearchIndex = -1;
    renderThreadList();
    renderChat();
    
    // Scroll to specific message if it's a message search result
    if (messageIndex >= 0) {
      setTimeout(() => {
        scrollToMessage(messageIndex);
      }, 100);
    } else {
      focusInputBox();
    }
  }

  function scrollToMessage(messageIndex) {
    const chat = document.getElementById('chat');
    const messages = chat.querySelectorAll('.message');
    
    if (messageIndex >= 0 && messageIndex < messages.length) {
      const targetMessage = messages[messageIndex];
      
      // Add highlight effect
      targetMessage.classList.add('highlighted-message');
      
      // Scroll to message
      targetMessage.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'center' 
      });
      
      // Remove highlight after a few seconds
      setTimeout(() => {
        targetMessage.classList.remove('highlighted-message');
      }, 3000);
    }
  }

  function updateSearchSelection() {
    const items = document.querySelectorAll('.search-result-item');
    items.forEach((item, index) => {
      if (index === selectedSearchIndex) {
        item.classList.add('selected');
        item.scrollIntoView({ block: 'nearest' });
      } else {
        item.classList.remove('selected');
      }
    });
  }

  document.getElementById('searchInput').addEventListener('input', (e) => {
    searchQuery = e.target.value.trim();

    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
      const results = performSearch(searchQuery);
      displaySearchResults(results, searchQuery);
    }, 300); // Debounce for 300ms
  });

  // Keyboard navigation for search results
  document.getElementById('searchInput').addEventListener('keydown', (e) => {
    const searchResults = document.getElementById('searchResults');
    const items = searchResults.querySelectorAll('.search-result-item');
    
    if (!searchResults.classList.contains('active') || items.length === 0) {
      return;
    }

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        selectedSearchIndex = Math.min(selectedSearchIndex + 1, items.length - 1);
        updateSearchSelection();
        break;
      
      case 'ArrowUp':
        e.preventDefault();
        selectedSearchIndex = Math.max(selectedSearchIndex - 1, -1);
        updateSearchSelection();
        break;
      
      case 'Enter':
        e.preventDefault();
        if (selectedSearchIndex >= 0 && selectedSearchIndex < items.length) {
          selectSearchResult(items[selectedSearchIndex]);
        }
        break;
      
      case 'Escape':
        e.preventDefault();
        searchResults.classList.remove('active');
        selectedSearchIndex = -1;
        break;
    }
  });

  document.getElementById('searchInput').addEventListener('focus', () => {
    if (searchQuery) {
      const results = performSearch(searchQuery);
      displaySearchResults(results, searchQuery);
    }
  });

  // Close search results when clicking outside
  document.addEventListener('click', (e) => {
    const searchContainer = document.querySelector('.search-container');
    if (!searchContainer.contains(e.target)) {
      document.getElementById('searchResults').classList.remove('active');
    }
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Search shortcut (Ctrl+K or Cmd+K)
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
      e.preventDefault();
      const searchInput = document.getElementById('searchInput');
      searchInput.focus();
      searchInput.select();
      return;
    }
    
    // Focus message input shortcut (Cmd+/ or Ctrl+/)
    if ((e.ctrlKey || e.metaKey) && e.key === '/') {
      e.preventDefault();
      const messageInput = document.getElementById('input');
      if (messageInput && !messageInput.disabled) {
        messageInput.focus();
      }
      return;
    }
    
    // New thread shortcut (Cmd+L or Ctrl+L)
    if ((e.ctrlKey || e.metaKey) && e.key === 'l') {
      e.preventDefault();
      addNewThread();
      return;
    }
  });

  // Filter functionality
  document.querySelectorAll('.filter-chip').forEach(chip => {
    chip.addEventListener('click', () => {
      document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
      chip.classList.add('active');
      currentFilter = chip.getAttribute('data-filter');
      renderThreadList();
    });
  });

  function filterThreads() {
    return threadOrder.filter(id => {
      const thread = threads[id];
      if (!thread) return false;

      switch (currentFilter) {
        case 'unread':
          return getUnreadCount(id) > 0;
        default:
          return true;
      }
    });
  }

  // SVG Icons
  const icons = {
    edit: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M2.695 14.763l-1.262 3.154a.5.5 0 00.65.65l3.155-1.262a4 4 0 001.343-.885L17.5 5.5a2.121 2.121 0 00-3-3L3.581 13.42a4 4 0 00-.886 1.343z" /></svg>',
    trash: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.584.176-2.365.298a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193V3.75A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clip-rule="evenodd" /></svg>',
    copy: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>',
    check: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.05-.143z" clip-rule="evenodd" /></svg>',
    send: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M3.105 2.289a.75.75 0 00-.826.95l1.414 4.925A1.5 1.5 0 005.135 9.25h6.115a.75.75 0 010 1.5H5.135a1.5 1.5 0 00-1.442 1.086l-1.414 4.926a.75.75 0 00.826.95 28.896 28.896 0 0015.293-7.154.75.75 0 000-1.115A28.896 28.896 0 003.105 2.289z"/></svg>'
  };

  function uuidv4() {
    if (window.crypto?.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  let apiKey = localStorage.getItem('apiKey') || '';
  let assistantId = localStorage.getItem('assistantId') || '';
  let renderMarkdown = localStorage.getItem('renderMarkdown') !== 'false'; // Default to true
  let autoNaming = localStorage.getItem('autoNaming') !== 'false'; // Default to true
  let autoCompleteEnabled = localStorage.getItem('autoCompleteEnabled') !== 'false'; // Default to true
  let autoCompleteModel = localStorage.getItem('autoCompleteModel') || 'gpt-3.5-turbo'; // Default to GPT-3.5-turbo
  let currentTheme = localStorage.getItem('theme') || 'dark'; // Default to dark
  let sidebarCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
  let sidebarWidth = parseInt(localStorage.getItem('sidebarWidth')) || 280;

  // Auto-completion variables
  let autoCompleteTimeout = null;
  let currentCompletion = '';
  let isAutoCompleteActive = false;
  let selectedSuggestionIndex = -1;
  let lastRequestedQuery = '';

  // Notification variables
  let notificationsEnabled = localStorage.getItem('notificationsEnabled') !== 'false'; // Default to true
  let isTabActive = true;

  // Initialize theme
  document.body.setAttribute('data-theme', currentTheme);
  updateThemeIcon();

  // Request notification permission on load
  async function requestNotificationPermission() {
    // Don't request notifications for local file URLs
    if (window.location.protocol === 'file:') {
      return;
    }
    
    if ('Notification' in window && Notification.permission === 'default') {
      try {
        await Notification.requestPermission();
      } catch (error) {
        // Permission request failed
      }
    }
  }

  // Track tab visibility
  document.addEventListener('visibilitychange', () => {
    isTabActive = !document.hidden;
    if (isTabActive) {
      // Clear any existing notifications when tab becomes active
      clearNotifications();
      // Update last read timestamp for current thread
      if (currentThreadId) {
        updateLastReadTimestamp(currentThreadId);
        renderThreadList();
      }
    }
  });

  // Show notification for new message
  function showNotification(threadName, messageText, threadId) {
    // Don't show notifications for local file URLs
    if (window.location.protocol === 'file:') {
      return;
    }
    
    if (!notificationsEnabled || isTabActive || Notification.permission !== 'granted') {
      return;
    }

    // Truncate long messages
    const truncatedText = messageText.length > 100 ? 
      messageText.substring(0, 100) + '...' : 
      messageText;

    const notification = new Notification(`New message in ${threadName}`, {
      body: truncatedText,
      icon: 'favicon.ico',
      tag: `thread-${threadId}`, // This replaces previous notifications for the same thread
      requireInteraction: false,
      silent: false
    });

    // Auto-close notification after 5 seconds
    setTimeout(() => {
      notification.close();
    }, 5000);

    // Click notification to focus the thread
    notification.onclick = () => {
      window.focus();
      if (threadId !== currentThreadId) {
        currentThreadId = threadId;
        localStorage.setItem('currentThreadId', currentThreadId);
        renderThreadList();
        renderChat();
      }
      notification.close();
    };
  }

  // Clear all notifications
  function clearNotifications() {
    // This is a best-effort approach since there's no direct way to clear all notifications
    // The tag-based replacement in showNotification helps manage this
  }

  // Request permission when the app loads
  requestNotificationPermission();

  function updateThemeIcon() {
    const sunIcon = document.querySelector('.sun-icon');
    const moonIcon = document.querySelector('.moon-icon');
    if (currentTheme === 'dark') {
      // In dark mode, show sun icon (to switch to light)
      sunIcon.style.display = 'block';
      moonIcon.style.display = 'none';
    } else {
      // In light mode, show moon icon (to switch to dark)
      sunIcon.style.display = 'none';
      moonIcon.style.display = 'block';
    }
  }

  document.getElementById('themeToggle').addEventListener('click', () => {
    currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
    document.body.setAttribute('data-theme', currentTheme);
    localStorage.setItem('theme', currentTheme);
    updateThemeIcon();
  });

  // Sidebar functionality
  function initializeSidebar() {
    const sidebar = document.querySelector('.sidebar');
    const root = document.documentElement;
    
    // Set initial width
    root.style.setProperty('--sidebar-width', `${sidebarWidth}px`);
    
    // Set initial collapsed state
    if (sidebarCollapsed) {
      sidebar.classList.add('collapsed');
      updateToggleIcon(true);
    }
  }

  function updateToggleIcon(collapsed) {
    const collapseIcon = document.querySelector('.collapse-icon');
    const expandIcon = document.querySelector('.expand-icon');
    
    if (collapsed) {
      collapseIcon.style.display = 'none';
      expandIcon.style.display = 'block';
    } else {
      collapseIcon.style.display = 'block';
      expandIcon.style.display = 'none';
    }
  }

  document.getElementById('sidebarToggle').addEventListener('click', () => {
    const sidebar = document.querySelector('.sidebar');
    sidebarCollapsed = !sidebarCollapsed;
    
    if (sidebarCollapsed) {
      sidebar.classList.add('collapsed');
    } else {
      sidebar.classList.remove('collapsed');
    }
    
    updateToggleIcon(sidebarCollapsed);
    localStorage.setItem('sidebarCollapsed', sidebarCollapsed.toString());
  });

  // Sidebar resize functionality
  function initializeSidebarResize() {
    const resizeHandle = document.querySelector('.sidebar-resize-handle');
    const sidebar = document.querySelector('.sidebar');
    const root = document.documentElement;
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    resizeHandle.addEventListener('mousedown', (e) => {
      if (sidebarCollapsed) return;
      
      isResizing = true;
      startX = e.clientX;
      startWidth = sidebarWidth;
      resizeHandle.classList.add('dragging');
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
      
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      
      const deltaX = e.clientX - startX;
      const newWidth = Math.max(200, Math.min(500, startWidth + deltaX));
      
      sidebarWidth = newWidth;
      root.style.setProperty('--sidebar-width', `${newWidth}px`);
    });

    document.addEventListener('mouseup', () => {
      if (!isResizing) return;
      
      isResizing = false;
      resizeHandle.classList.remove('dragging');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      
      localStorage.setItem('sidebarWidth', sidebarWidth.toString());
    });
  }

  let threads = JSON.parse(localStorage.getItem('threadsV2')) || {};
  let threadOrder = JSON.parse(localStorage.getItem('threadOrder')) || [];
  let currentThreadId = localStorage.getItem('currentThreadId') || null;

  // Track last read message timestamp for each thread
  let lastReadTimestamps = JSON.parse(localStorage.getItem('lastReadTimestamps')) || {};
  
  // Track draft messages for each thread
  let threadDrafts = JSON.parse(localStorage.getItem('threadDrafts')) || {};

  // Draft message management
  function saveDraftMessage(threadId, message) {
    if (!threadId) return;
    
    if (message.trim()) {
      threadDrafts[threadId] = message;
    } else {
      delete threadDrafts[threadId];
    }
    localStorage.setItem('threadDrafts', JSON.stringify(threadDrafts));
  }

  function loadDraftMessage(threadId) {
    if (!threadId) return '';
    return threadDrafts[threadId] || '';
  }

  function clearDraftMessage(threadId) {
    if (!threadId) return;
    delete threadDrafts[threadId];
    localStorage.setItem('threadDrafts', JSON.stringify(threadDrafts));
  }

  // Clean up any stuck "generating name" states on page load
  function cleanupGeneratingStates() {
    let hasChanges = false;
    for (const threadId in threads) {
      if (threads[threadId].generatingName) {
        threads[threadId].generatingName = false;
        hasChanges = true;
      }
    }
    if (hasChanges) {
      persistThreads();
    }
  }

  function updateLastReadTimestamp(threadId) {
    if (!threadId || !threads[threadId]) return;
    const chatHistory = threads[threadId].chatHistory || [];
    if (chatHistory.length > 0) {
      const lastMsg = chatHistory[chatHistory.length - 1];
      lastReadTimestamps[threadId] = new Date(lastMsg.timestamp).getTime();
      localStorage.setItem('lastReadTimestamps', JSON.stringify(lastReadTimestamps));
    }
  }

  function getUnreadCount(threadId) {
    if (!threads[threadId]) return 0;
    const lastRead = lastReadTimestamps[threadId] || 0;
    const chatHistory = threads[threadId].chatHistory || [];
    return chatHistory.filter(msg => {
      const msgTime = new Date(msg.timestamp).getTime();
      return msgTime > lastRead && msg.sender === 'assistant';
    }).length;
  }

  function isAwaitingResponse(threadId) {
    const thread = threads[threadId];
    if (!thread || !thread.chatHistory || thread.chatHistory.length === 0) return false;
    
    // Check if the last message was from the user
    const lastMessage = thread.chatHistory[thread.chatHistory.length - 1];
    return lastMessage.sender === 'user';
  }

  // Auto-naming function using GPT-4o-mini
  async function generateThreadName(firstMessage, threadId) {
    if (!autoNaming || !apiKey || !threadId || !threads[threadId]) return null;
    
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: 'Generate a concise, descriptive title (max 4-5 words) for a conversation that starts with the given message. The title should capture the main topic or intent. Return only the title, no quotes or extra text.'
            },
            {
              role: 'user',
              content: firstMessage
            }
          ],
          max_tokens: 20,
          temperature: 0.7
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();
      const generatedName = data.choices?.[0]?.message?.content?.trim();
      
      // Validate the generated name and check if thread still exists
      if (generatedName && generatedName.length > 0 && generatedName.length <= 50 && threads[threadId]) {
        return generatedName;
      }
    } catch (error) {
      console.error('Failed to generate thread name:', error);
    }
    
    return null;
  }

  async function syncThreadWithOpenAI(threadId) {
    const threadObj = threads[threadId];
    if (!threadObj || !threadObj.threadId) return;

    let hasNewMessages = false;

    try {
      const messagesResponse = await fetch(`https://api.openai.com/v1/threads/${threadObj.threadId}/messages`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'OpenAI-Beta': 'assistants=v2'
        }
      });
      const messagesData = await messagesResponse.json();
      const messages = messagesData.data;
      const seenMsgIds = new Set(
        (threadObj.chatHistory || []).map(m => m.msgId).filter(Boolean)
      );
      const seenClientMsgIds = new Set(
        (threadObj.chatHistory || [])
          .filter(m => m.sender === 'user' && m.clientMsgId)
          .map(m => m.clientMsgId)
      );
      const sortedMessages = messages.slice().sort((a, b) => a.created_at - b.created_at);
      for (const msg of sortedMessages) {
        if (
          (msg.role === 'assistant' || msg.role === 'user') &&
          msg.content && msg.content[0] && msg.content[0].type === 'text'
        ) {
          if (msg.role === 'user') {
            const clientMsgId = msg.metadata?.clientMsgId;
            if (clientMsgId && seenClientMsgIds.has(clientMsgId)) continue;
          }
          if (!seenMsgIds.has(msg.id)) {
            const sender = msg.role === 'assistant' ? 'assistant' : 'user';
            const entry = {
              text: msg.content[0].text.value,
              sender: sender,
              timestamp: new Date(msg.created_at * 1000),
              msgId: msg.id
            };
            if (msg.role === 'user' && msg.metadata?.clientMsgId) {
              entry.clientMsgId = msg.metadata.clientMsgId;
              seenClientMsgIds.add(msg.metadata.clientMsgId);
            }
            threadObj.chatHistory.push(entry);
            seenMsgIds.add(msg.id);

            // Track if we got new assistant messages
            if (sender === 'assistant') {
              hasNewMessages = true;
            }
          }
        }
      }
      threads[threadId] = threadObj;
      persistThreads();

      // If this is a background thread with new messages, update the thread list
      if (hasNewMessages && threadId !== currentThreadId) {
        renderThreadList();
      }
    } catch (e) { /* fail silently */ }
  }

  function scrollChatToBottom() {
    const chat = document.getElementById('chat');
    chat.scrollTop = chat.scrollHeight;
  }

  function restoreInputEnabled() {
    let threadObj = threads[currentThreadId];
    if (!threadObj) return;
    
    const enabled = threadObj.inputEnabled ?? true;
    const sendButton = document.getElementById('send');
    
    sendButton.disabled = !enabled;
    document.getElementById('input').disabled = !enabled;
    
    if (!enabled) {
      sendButton.innerHTML = '<div class="spinner"></div>';
    } else {
      sendButton.innerHTML = icons.send;
    }
  }

  function setInputEnabled(enabled) {
    if (currentThreadId && threads[currentThreadId]) {
      threads[currentThreadId].inputEnabled = enabled;
      const sendButton = document.getElementById('send');
      
      sendButton.disabled = !enabled;
      document.getElementById('input').disabled = !enabled;
      
      if (!enabled) {
        sendButton.innerHTML = '<div class="spinner"></div>';
      } else {
        sendButton.innerHTML = icons.send;
      }
      
      persistThreads();
    }
  }

  async function renderChat() {
    const chat = document.getElementById('chat');
    chat.innerHTML = '';
    document.getElementById('currentThreadLabel').textContent =
      currentThreadId && threads[currentThreadId] ? threads[currentThreadId].displayName : '';

    if (!currentThreadId || !threads[currentThreadId]) {
      // Show welcome message when no thread selected
      if (!apiKey || !assistantId) {
        chat.innerHTML = `
          <div class="welcome-message">
            <h2>Welcome to Ailo Support Assistant</h2>
            <p>Please configure your API Key and Assistant ID in Settings to begin.</p>
          </div>
        `;
      }
      return;
    }

    const threadObj = threads[currentThreadId];

    // Check if there are unread messages before rendering
    const lastRead = lastReadTimestamps[currentThreadId] || 0;
    const hasUnreadMessages = (threadObj.chatHistory || []).some(entry => {
      const msgTime = new Date(entry.timestamp).getTime();
      return msgTime > lastRead && entry.sender === 'assistant';
    });

    // Show messages with unread divider if there are unread messages
    if (hasUnreadMessages) {
      let hasShownUnreadDivider = false;
      (threadObj.chatHistory || []).forEach(entry => {
        const msgTime = new Date(entry.timestamp).getTime();
        
        // Show divider before the first unread assistant message
        if (!hasShownUnreadDivider && msgTime > lastRead && entry.sender === 'assistant') {
          const divider = document.createElement('div');
          divider.className = 'unread-divider';
          divider.textContent = 'New messages';
          document.getElementById('chat').appendChild(divider);
          hasShownUnreadDivider = true;
        }
        
        addMessageToChat(entry.text, entry.sender, entry.timestamp, true);
      });
    } else {
      // No unread messages, just show all messages normally
      (threadObj.chatHistory || []).forEach(entry => {
        addMessageToChat(entry.text, entry.sender, entry.timestamp, true);
      });
    }

    // Update last read timestamp for current thread
    updateLastReadTimestamp(currentThreadId);
    renderThreadList(); // Update to remove unread badge from current thread

    scrollChatToBottom();

    // Load draft message for this thread
    const input = document.getElementById('input');
    if (input) {
      const draftMessage = loadDraftMessage(currentThreadId);
      input.value = draftMessage;
    }

    let pendingRun = threadObj.lastRunId && threadObj.lastRunStatus === 'in_progress';
    if (pendingRun) {
      threads[currentThreadId].inputEnabled = false;
    } else {
      threads[currentThreadId].inputEnabled = true;
    }
    restoreInputEnabled();

    if (pendingRun) addTypingIndicator();
    if (pendingRun) scrollChatToBottom();

    (async () => {
      let needsRerender = false;
      if (pendingRun) {
        setInputEnabled(false);
        let runStatus = 'in_progress';
        try {
          while (runStatus === 'in_progress') {
            await new Promise(resolve => setTimeout(resolve, 1000));
            const statusResponse = await fetch(
              `https://api.openai.com/v1/threads/${threadObj.threadId}/runs/${threadObj.lastRunId}`,
              {
                method: 'GET',
                headers: {
                  'Authorization': `Bearer ${apiKey}`,
                  'OpenAI-Beta': 'assistants=v2'
                }
              }
            );
            const statusData = await statusResponse.json();
            runStatus = statusData.status;
            threadObj.lastRunStatus = runStatus;
            threads[threadObj.id] = threadObj;
            persistThreads();
          }
        } catch (e) {}
        threadObj.lastRunId = null;
        threadObj.lastRunStatus = null;
        threads[threadObj.id] = threadObj;
        persistThreads();
        setInputEnabled(true);
        needsRerender = true;
      }
      let beforeMsgCount = (threads[currentThreadId]?.chatHistory || []).length;
      await syncThreadWithOpenAI(currentThreadId);
      let afterMsgCount = (threads[currentThreadId]?.chatHistory || []).length;
      if (needsRerender || afterMsgCount > beforeMsgCount) {
        chat.innerHTML = '';

        // Only show unread divider if we're re-rendering due to new messages
        const showUnreadDivider = afterMsgCount > beforeMsgCount;
        const lastRead = lastReadTimestamps[currentThreadId] || 0;
        let hasShownUnreadDivider = false;

        (threads[currentThreadId].chatHistory || []).forEach(entry => {
          const msgTime = new Date(entry.timestamp).getTime();

          // Only show divider for new messages that arrived while viewing this thread
          if (showUnreadDivider && !hasShownUnreadDivider && msgTime > lastRead && entry.sender === 'assistant') {
            const divider = document.createElement('div');
            divider.className = 'unread-divider';
            divider.textContent = 'New messages';
            chat.appendChild(divider);
            hasShownUnreadDivider = true;
          }

          addMessageToChat(entry.text, entry.sender, entry.timestamp, true);
        });

        updateLastReadTimestamp(currentThreadId);
        renderThreadList();
        scrollChatToBottom();
        restoreInputEnabled();
      }
    })();
  }

  function renderThreadList() {
    const container = document.getElementById('threadList');
    container.innerHTML = '';

    const filteredThreads = filterThreads();

    if (filteredThreads.length === 0) {
      let emptyMessage = 'No conversations yet';
      if (currentFilter === 'unread') emptyMessage = 'No unread conversations';

      container.innerHTML = `<div class="empty-state">${emptyMessage}</div>`;
      return;
    }

    filteredThreads.forEach((id) => {
      const t = threads[id];
      if (!t) return;

      const threadItem = document.createElement('div');
      threadItem.className = 'thread-item' + (currentThreadId === id ? ' active' : '');

      const unreadCount = getUnreadCount(id);
      const unreadBadge = unreadCount > 0 ? `<span class="unread-badge">${unreadCount}</span>` : '';
      
      // Check if thread is awaiting response (only show if no unread messages)
      const awaitingResponse = unreadCount === 0 && isAwaitingResponse(id);
      const awaitingIndicator = awaitingResponse ? `<div class="awaiting-response" title="Awaiting response"></div>` : '';
      
      // Check if thread name is being generated
      const isGenerating = t.displayName.startsWith('Thread ') && t.generatingName;
      const nameClass = isGenerating ? 'thread-name generating' : 'thread-name';
      const displayName = isGenerating ? 'Generating name...' : t.displayName;

      threadItem.innerHTML = `
        <span class="${nameClass}" data-thread-id="${id}">${displayName}</span>
        ${unreadBadge}
        ${awaitingIndicator}
        <div class="thread-actions">
          <button class="thread-btn edit-btn" title="Rename">${icons.edit}</button>
          <button class="thread-btn delete-btn" title="Delete">${icons.trash}</button>
        </div>
      `;

      const threadNameEl = threadItem.querySelector('.thread-name');

      // Click on thread to switch
      threadItem.onclick = (e) => {
        if (e.target.closest('.thread-actions')) return;
        currentThreadId = id;
        localStorage.setItem('currentThreadId', currentThreadId);
        renderThreadList();
        renderChat();
        focusInputBox();
      };

      // Double-click to edit inline (but not if generating)
      if (!isGenerating) {
        threadNameEl.ondblclick = (e) => {
          e.stopPropagation();
          startInlineEdit(threadNameEl, id);
        };
      }

      threadItem.querySelector('.edit-btn').onclick = (e) => {
        e.stopPropagation();
        if (!isGenerating) {
          const nameEl = threadItem.querySelector('.thread-name');
          startInlineEdit(nameEl, id);
        }
      };

      threadItem.querySelector('.delete-btn').onclick = (e) => {
        e.stopPropagation();
        if (confirm(`Delete "${t.displayName}"? This action cannot be undone.`)) {
          delete threads[id];
          delete lastReadTimestamps[id];
          clearDraftMessage(id); // Clear draft message for deleted thread
          threadOrder = threadOrder.filter(x => x !== id);
          if (currentThreadId === id) {
            currentThreadId = threadOrder[0] || null;
          }
          persistThreads();
          localStorage.setItem('lastReadTimestamps', JSON.stringify(lastReadTimestamps));
          renderThreadList();
          renderChat();
        }
      };

      container.appendChild(threadItem);
    });
  }

  function startInlineEdit(nameEl, threadId) {
    const t = threads[threadId];
    if (!t || t.generatingName) return;

    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'thread-name-input';
    input.value = t.displayName;

    nameEl.replaceWith(input);
    input.focus();
    input.select();

    const saveEdit = () => {
      const newName = input.value.trim();
      if (newName && newName !== t.displayName) {
        t.displayName = newName;
        t.generatingName = false; // Stop any name generation
        threads[threadId] = t;
        persistThreads();
      }
      renderThreadList();
      if (currentThreadId === threadId) {
        renderChat();
      }
    };

    input.onkeydown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveEdit();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        renderThreadList();
      }
    };

    input.onblur = saveEdit;
    input.onclick = (e) => e.stopPropagation();
  }

  function getNextDefaultThreadName() {
    let n = 1;
    while (threadOrder.some(id => threads[id]?.displayName === `Thread ${n}`)) n++;
    return `Thread ${n}`;
  }

  async function createOpenAIThread() {
    const response = await fetch('https://api.openai.com/v1/threads', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        'OpenAI-Beta': 'assistants=v2'
      },
      body: JSON.stringify({})
    });
    const data = await response.json();
    return data.id;
  }

  async function addNewThread() {
    if (!apiKey || !assistantId) {
      alert('Please set your API Key and Assistant ID in Settings first.');
      return;
    }

    const threadId = await createOpenAIThread();
    const id = uuidv4();
    const displayName = getNextDefaultThreadName();
    threads[id] = { 
      id, 
      displayName, 
      threadId, 
      chatHistory: [], 
      lastAssistantMessageId: null, 
      lastRunId: null, 
      lastRunStatus: null, 
      inputEnabled: true,
      generatingName: false 
    };
    threadOrder.push(id);
    currentThreadId = id;
    persistThreads();
    renderThreadList();
    renderChat();
    focusInputBox();
  }

  function persistThreads() {
    localStorage.setItem('threadsV2', JSON.stringify(threads));
    localStorage.setItem('threadOrder', JSON.stringify(threadOrder));
    localStorage.setItem('currentThreadId', currentThreadId);
  }

  function focusInputBox(delay = 100) {
    setTimeout(() => {
      const inputElement = document.getElementById('input');
      if (inputElement && !inputElement.disabled) {
        inputElement.focus();
      }
    }, delay);
  }

  // Copy message function
  async function copyMessageToClipboard(text, button) {
    try {
      // Clean the text (remove citations)
      const cleanText = text.replace(/\d+:\d+[^]+/g, '');
      
      await navigator.clipboard.writeText(cleanText);
      
      // Show success animation
      button.classList.add('copied');
      button.innerHTML = icons.check;
      
      setTimeout(() => {
        button.classList.remove('copied');
        button.innerHTML = icons.copy;
      }, 1500);
    } catch (err) {
      console.error('Failed to copy text: ', err);
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = cleanText;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      
      // Show success animation
      button.classList.add('copied');
      button.innerHTML = icons.check;
      
      setTimeout(() => {
        button.classList.remove('copied');
        button.innerHTML = icons.copy;
      }, 1500);
    }
  }

  function addMessageToChat(text, sender, time = null, skipSave = false, msgId = null, clientMsgId = null, isNewMessage = false) {
    const chat = document.getElementById('chat');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}${isNewMessage ? ' new-message' : ''}`;

    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';

    const messageText = document.createElement('div');
    const cleanText = text.replace(/\d+:\d+[^]+/g, '');

    if (renderMarkdown && sender === 'assistant') {
      messageText.innerHTML = marked.parse(cleanText);
    } else {
      messageText.textContent = cleanText;
    }

    messageContent.appendChild(messageText);

    // Add copy button
    const copyButton = document.createElement('button');
    copyButton.className = 'copy-btn';
    copyButton.innerHTML = icons.copy;
    copyButton.title = 'Copy message';
    copyButton.onclick = (e) => {
      e.stopPropagation();
      copyMessageToClipboard(text, copyButton);
    };
    messageContent.appendChild(copyButton);

    messageDiv.appendChild(messageContent);

    const timestamp = document.createElement('div');
    timestamp.className = 'timestamp';
    const now = time ? new Date(time) : new Date();
    timestamp.textContent = now.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true });
    const fullDateTime = now.toLocaleString([], { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric', 
      hour: 'numeric', 
      minute: '2-digit', 
      second: '2-digit',
      hour12: true 
    });
    timestamp.setAttribute('data-tooltip', fullDateTime);
    timestamp.title = fullDateTime; // Keep as fallback
    messageDiv.appendChild(timestamp);

    chat.appendChild(messageDiv);

    if (!skipSave && currentThreadId && threads[currentThreadId]) {
      const entry = { text, sender, timestamp: now };
      if (msgId) entry.msgId = msgId;
      if (clientMsgId) entry.clientMsgId = clientMsgId;
      threads[currentThreadId].chatHistory.push(entry);
      persistThreads();
    }
  }

  function addTypingIndicator() {
    const chat = document.getElementById('chat');
    const typingDiv = document.createElement('div');
    typingDiv.className = 'message assistant';
    const typingContent = document.createElement('div');
    typingContent.className = 'typing-indicator';
    typingContent.textContent = 'Assistant is typing';
    typingDiv.appendChild(typingContent);
    chat.appendChild(typingDiv);
    return typingDiv;
  }

  document.getElementById('newThreadBtn').addEventListener('click', addNewThread);

  document.getElementById('send').addEventListener('click', async () => {
    if (!apiKey || !assistantId) {
      alert('Please set your API Key and Assistant ID in Settings first.');
      return;
    }
    const input = document.getElementById('input');
    const message = input.value.trim();
    if (message) {
      // If no current thread exists, create one
      if (!currentThreadId || !threads[currentThreadId]) {
        await addNewThread();
      }

      const threadObj = threads[currentThreadId];
      const isFirstMessage = !threadObj.chatHistory || threadObj.chatHistory.length === 0;

      setInputEnabled(false);
      const clientMsgId = uuidv4();
      addMessageToChat(message, 'user', null, false, null, clientMsgId, true);
      scrollChatToBottom(); // Scroll immediately after adding user message
      input.value = '';
      
      // Clear draft message for this thread since message was sent
      clearDraftMessage(currentThreadId);
      
      // Start auto-naming process for first message if enabled
      if (isFirstMessage && autoNaming && threadObj.displayName.startsWith('Thread ')) {
        threadObj.generatingName = true;
        threads[currentThreadId] = threadObj;
        persistThreads();
        renderThreadList(); // Update UI to show "Generating name..."
        
        // Generate name in background
        generateThreadName(message, currentThreadId).then(generatedName => {
          // Double-check that the thread still exists and is still in generating state
          if (generatedName && threads[currentThreadId] && threads[currentThreadId].generatingName) {
            threads[currentThreadId].displayName = generatedName;
            threads[currentThreadId].generatingName = false;
            persistThreads();
            renderThreadList();
            if (currentThreadId === threadObj.id) {
              renderChat(); // Update header
            }
          } else if (threads[currentThreadId] && threads[currentThreadId].generatingName) {
            // Fallback if generation failed but thread still exists
            threads[currentThreadId].generatingName = false;
            persistThreads();
            renderThreadList();
          }
        }).catch(error => {
          console.error('Error during name generation:', error);
          // Clean up generating state on error
          if (threads[currentThreadId] && threads[currentThreadId].generatingName) {
            threads[currentThreadId].generatingName = false;
            persistThreads();
            renderThreadList();
          }
        });
      }
      
      const thisThreadId = currentThreadId;
      await sendMessageWithClientMsgId(message, thisThreadId, clientMsgId);
    }
  });

  async function sendMessageWithClientMsgId(message, threadId, clientMsgId) {
    if (!threadId) {
      setInputEnabled(true);
      return;
    }
    let threadObj = threads[threadId];
    if (!threadObj.threadId) {
      threadObj.threadId = await createOpenAIThread();
      threads[threadId] = threadObj;
      persistThreads();
    }
    await fetch(`https://api.openai.com/v1/threads/${threadObj.threadId}/messages`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        'OpenAI-Beta': 'assistants=v2'
      },
      body: JSON.stringify({
        role: 'user',
        content: message,
        metadata: { clientMsgId }
      })
    });
    const runResponse = await fetch(`https://api.openai.com/v1/threads/${threadObj.threadId}/runs`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        'OpenAI-Beta': 'assistants=v2'
      },
      body: JSON.stringify({
        assistant_id: assistantId
      })
    });
    const runData = await runResponse.json();
    const runId = runData.id;
    threadObj.lastRunId = runId;
    threadObj.lastRunStatus = 'in_progress';
    threads[threadId] = threadObj;
    persistThreads();

    renderChat();
  }

  // Auto-completion functionality
  async function getAutoCompletion(partialText) {
    if (!apiKey || !currentThreadId || !threads[currentThreadId]) {
      return [];
    }

    const conversationHistory = threads[currentThreadId].chatHistory || [];
    if (conversationHistory.length === 0) {
      return [];
    }

    // Get last 10 messages for context
    const context = conversationHistory.slice(-10)
      .map(msg => `${msg.sender}: ${msg.text}`)
      .join('\n');

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: autoCompleteModel,
          messages: [
            {
              role: 'system',
              content: `You are helping complete a user's partial sentence based on conversation context. 
                       The user has started typing something and you need to complete their sentence naturally.
                       
                       Rules:
                       1. Continue the exact text the user has typed - don't start over
                       2. Provide 3-5 different ways to complete their sentence
                       3. Each completion should start with the user's partial text and continue naturally
                       4. Keep completions relevant to the conversation context
                       5. Return only the FULL completed sentences, one per line
                       
                       Example:
                       If user typed: "How can I"
                       Return completions like:
                       "How can I fix this error?"
                       "How can I improve performance?"
                       "How can I troubleshoot the issue?"`
            },
            {
              role: 'user',
              content: `Conversation context:\n${context}\n\nUser's partial text: "${partialText}"\n\nComplete this sentence in 3-5 different ways:`
            }
          ],
          max_tokens: 150,
          temperature: 0.7
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();
      const rawSuggestions = data.choices[0].message.content
        .split('\n')
        .map(s => s.trim())
        .map(s => s.replace(/^["']|["']$/g, '')) // Remove leading/trailing quotes
        .map(s => s.replace(/^[-*]\s*/, '')) // Remove bullet points (-, , *)
        .map(s => s.replace(/^\d+\.\s*/, '')) // Remove numbered lists (1., 2., etc.)
        .filter(s => s.length > 0);
      
      const suggestions = rawSuggestions
        .filter(s => {
          // Only include suggestions that start with the user's partial text
          const startsWithPartial = s.toLowerCase().startsWith(partialText.toLowerCase());
          const isLonger = s.length > partialText.length;
          return startsWithPartial && isLonger;
        })
        .slice(0, 5);
      return suggestions;
    } catch (error) {
      console.error('Auto-completion error:', error);
      return [];
    }
  }

  function highlightMatch(text, query) {
    if (!query) return text;
    // Escape special regex characters and create pattern that matches from start
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`^(${escapedQuery})`, 'i');
    return text.replace(regex, '<strong>$1</strong>');
  }

  function measureTextWidth(text, element) {
    // Create a canvas to measure text width precisely
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    const styles = window.getComputedStyle(element);
    
    // Set font properties to match the input element
    context.font = `${styles.fontWeight} ${styles.fontSize} ${styles.fontFamily}`;
    
    // Measure the text width
    const metrics = context.measureText(text);
    return metrics.width;
  }

  function showAutoCompleteSuggestions(suggestions, query) {
    // Check if the current input still matches the query we requested suggestions for
    const currentInput = document.getElementById('input').value.trim();
    if (currentInput !== query) {
      return;
    }
    
    if (suggestions.length === 0) {
      hideAutoComplete();
      return;
    }

    // Show inline completion with first suggestion
    showInlineCompletion(suggestions[0], query);
    
    // Show dropdown with all suggestions
    showDropdownSuggestions(suggestions, query);
  }

  function showInlineCompletion(bestSuggestion, query) {
    const completion = bestSuggestion.substring(query.length);
    
    currentCompletion = bestSuggestion;
    isAutoCompleteActive = true;

    // Update the ghost text with proper positioning
    const ghostElement = document.getElementById('input-ghost');
    const inputWrapper = document.querySelector('.input-wrapper');
    const input = document.getElementById('input');
    
    if (ghostElement && inputWrapper && input) {
      // Measure the text width using canvas for precision
      const textWidth = measureTextWidth(query, input);
      
      // Position the ghost text after the typed text, accounting for input padding (16px)
      ghostElement.style.left = `${16 + textWidth}px`;
      ghostElement.innerHTML = `<span class="ghost-text">${completion}</span>`;
      inputWrapper.classList.add('has-completion');
    }
  }

  function showDropdownSuggestions(suggestions, query) {
    const container = document.getElementById('autocompleteSuggestions');
    selectedSuggestionIndex = -1; // Reset selection
    
    const suggestionsHtml = suggestions.map((suggestion, index) => {
      const completion = suggestion.substring(query.length);
      return `
        <div class="suggestion-item" data-index="${index}" data-suggestion="${suggestion}">
          <div class="suggestion-content">
            <div class="suggestion-text">
              <span class="suggestion-prefix">${query}</span><span class="suggestion-completion">${completion}</span>
            </div>
            <div class="suggestion-meta">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M9.664 1.319a.75.75 0 01.672 0 41.059 41.059 0 018.198 5.424.75.75 0 01-.254 1.285 31.372 31.372 0 00-7.86 3.83.75.75 0 01-.84 0 31.508 31.508 0 00-2.08-1.287V9.394c0-.244.116-.463.302-.592a35.504 35.504 0 013.305-2.033.75.75 0 00-.714-1.319 37 37 0 00-3.446 2.12A2.216 2.216 0 006 9.393v.38a31.293 31.293 0 00-4.28-1.746.75.75 0 01-.254-1.285 41.059 41.059 0 018.198-5.424zM6 11.459a29.848 29.848 0 00-2.455-1.158 41.029 41.029 0 00-.39 3.114.75.75 0 00.419.74c.528.256 1.046.53 1.554.82-.21-.899-.455-1.746-.721-2.517zm.286 1.961a.75.75 0 01.848.06 28.424 28.424 0 002.729 1.554 28.424 28.424 0 002.729-1.554.75.75 0 01.848-.06c.26.156.519.312.776.472-.526 1.798-1.297 3.486-2.209 4.615a.75.75 0 01-1.238 0c-.912-1.129-1.683-2.817-2.209-4.615.257-.16.516-.316.776-.472z" clip-rule="evenodd" />
              </svg>
              AI suggestion ${index + 1}
            </div>
          </div>
          <div class="suggestion-shortcut">${index === 0 ? 'Tab' : `${index + 1}`}</div>
        </div>
      `;
    }).join('');

    container.innerHTML = `
      <div class="suggestions-header">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M9.664 1.319a.75.75 0 01.672 0 41.059 41.059 0 018.198 5.424.75.75 0 01-.254 1.285 31.372 31.372 0 00-7.86 3.83.75.75 0 01-.84 0 31.508 31.508 0 00-2.08-1.287V9.394c0-.244.116-.463.302-.592a35.504 35.504 0 013.305-2.033.75.75 0 00-.714-1.319 37 37 0 00-3.446 2.12A2.216 2.216 0 006 9.393v.38a31.293 31.293 0 00-4.28-1.746.75.75 0 01-.254-1.285 41.059 41.059 0 018.198-5.424zM6 11.459a29.848 29.848 0 00-2.455-1.158 41.029 41.029 0 00-.39 3.114.75.75 0 00.419.74c.528.256 1.046.53 1.554.82-.21-.899-.455-1.746-.721-2.517zm.286 1.961a.75.75 0 01.848.06 28.424 28.424 0 002.729 1.554 28.424 28.424 0 002.729-1.554.75.75 0 01.848-.06c.26.156.519.312.776.472-.526 1.798-1.297 3.486-2.209 4.615a.75.75 0 01-1.238 0c-.912-1.129-1.683-2.817-2.209-4.615.257-.16.516-.316.776-.472z" clip-rule="evenodd" />
        </svg>
        AI Suggestions
      </div>
      <div class="suggestions-list">
        ${suggestionsHtml}
      </div>
    `;
    
    container.classList.add('active');
    
    // Add click handlers
    container.querySelectorAll('.suggestion-item').forEach(item => {
      item.onclick = () => {
        const suggestion = item.getAttribute('data-suggestion');
        acceptSuggestion(suggestion);
      };
    });
  }

  function hideAutoComplete() {
    hideInlineCompletion();
    hideDropdownSuggestions();
  }

  function hideInlineCompletion() {
    const ghostElement = document.getElementById('input-ghost');
    const inputWrapper = document.querySelector('.input-wrapper');
    
    if (ghostElement) {
      ghostElement.innerHTML = '';
      ghostElement.style.left = '16px'; // Reset position
    }
    if (inputWrapper) {
      inputWrapper.classList.remove('has-completion');
    }
    isAutoCompleteActive = false;
    currentCompletion = '';
  }

  function hideDropdownSuggestions() {
    const container = document.getElementById('autocompleteSuggestions');
    container.classList.remove('active');
    container.innerHTML = '';
    selectedSuggestionIndex = -1;
  }

  function acceptInlineCompletion() {
    if (currentCompletion) {
      acceptSuggestion(currentCompletion);
    }
  }

  function acceptSuggestion(suggestion) {
    const input = document.getElementById('input');
    input.value = suggestion;
    hideAutoComplete();
    input.focus();
    // Move cursor to end
    input.setSelectionRange(input.value.length, input.value.length);
  }

  function updateSuggestionSelection() {
    const items = document.querySelectorAll('.suggestion-item');
    items.forEach((item, index) => {
      if (index === selectedSuggestionIndex) {
        item.classList.add('selected');
        item.scrollIntoView({ block: 'nearest' });
      } else {
        item.classList.remove('selected');
      }
    });
  }



  function showAutoCompleteLoading() {
    const container = document.getElementById('autocompleteSuggestions');
    container.innerHTML = `
      <div class="suggestions-header">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M9.664 1.319a.75.75 0 01.672 0 41.059 41.059 0 018.198 5.424.75.75 0 01-.254 1.285 31.372 31.372 0 00-7.86 3.83.75.75 0 01-.84 0 31.508 31.508 0 00-2.08-1.287V9.394c0-.244.116-.463.302-.592a35.504 35.504 0 013.305-2.033.75.75 0 00-.714-1.319 37 37 0 00-3.446 2.12A2.216 2.216 0 006 9.393v.38a31.293 31.293 0 00-4.28-1.746.75.75 0 01-.254-1.285 41.059 41.059 0 018.198-5.424zM6 11.459a29.848 29.848 0 00-2.455-1.158 41.029 41.029 0 00-.39 3.114.75.75 0 00.419.74c.528.256 1.046.53 1.554.82-.21-.899-.455-1.746-.721-2.517zm.286 1.961a.75.75 0 01.848.06 28.424 28.424 0 002.729 1.554 28.424 28.424 0 002.729-1.554.75.75 0 01.848-.06c.26.156.519.312.776.472-.526 1.798-1.297 3.486-2.209 4.615a.75.75 0 01-1.238 0c-.912-1.129-1.683-2.817-2.209-4.615.257-.16.516-.316.776-.472z" clip-rule="evenodd" />
        </svg>
        AI Suggestions
      </div>
      <div class="autocomplete-loading">
        <div class="spinner"></div>
        Getting AI suggestions...
      </div>
    `;
    container.classList.add('active');
  }

  // Input event handlers
  document.getElementById('input').addEventListener('input', async (e) => {
    const value = e.target.value;
    const trimmedValue = value.trim();
    
    // Save draft message for current thread
    if (currentThreadId) {
      saveDraftMessage(currentThreadId, value);
    }
    
    // Clear existing timeout
    clearTimeout(autoCompleteTimeout);
    
    // Always hide existing completion first to prevent overlap
    hideAutoComplete();
    
    // Check if auto-completion is enabled
    if (!autoCompleteEnabled) {
      return;
    }
    
    // Hide suggestions if input is too short
    if (trimmedValue.length < 5) {
      return;
    }

    // Debounce API calls
    autoCompleteTimeout = setTimeout(async () => {
      // Store the query we're requesting suggestions for
      lastRequestedQuery = trimmedValue;
      
      try {
        const suggestions = await getAutoCompletion(trimmedValue);
        showAutoCompleteSuggestions(suggestions, trimmedValue);
      } catch (error) {
        console.error('Auto-completion failed:', error);
        hideAutoComplete();
      }
    }, 500); // 500ms debounce
  });

  document.getElementById('input').addEventListener('keydown', (e) => {
    if (!autoCompleteEnabled || !isAutoCompleteActive) {
      return;
    }

    const container = document.getElementById('autocompleteSuggestions');
    const isDropdownActive = container.classList.contains('active');
    const items = container.querySelectorAll('.suggestion-item');

    switch (e.key) {
      case 'Tab':
        e.preventDefault();
        if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < items.length) {
          const suggestion = items[selectedSuggestionIndex].getAttribute('data-suggestion');
          acceptSuggestion(suggestion);
        } else {
          acceptInlineCompletion();
        }
        break;
      
      case 'ArrowDown':
        if (isDropdownActive && items.length > 0) {
          e.preventDefault();
          selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, items.length - 1);
          updateSuggestionSelection();
        }
        break;
      
      case 'ArrowUp':
        if (isDropdownActive && items.length > 0) {
          e.preventDefault();
          selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
          updateSuggestionSelection();
        }
        break;
      
      case 'Enter':
        if (isDropdownActive && selectedSuggestionIndex >= 0 && selectedSuggestionIndex < items.length) {
          e.preventDefault();
          const suggestion = items[selectedSuggestionIndex].getAttribute('data-suggestion');
          acceptSuggestion(suggestion);
        }
        break;
      
      case 'ArrowRight':
        // Accept completion with right arrow if cursor is at end
        const input = e.target;
        if (input.selectionStart === input.value.length) {
          e.preventDefault();
          if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < items.length) {
            const suggestion = items[selectedSuggestionIndex].getAttribute('data-suggestion');
            acceptSuggestion(suggestion);
          } else {
            acceptInlineCompletion();
          }
        }
        break;
      
      case 'Escape':
        e.preventDefault();
        hideAutoComplete();
        break;
      
      // Number keys 1-9 for quick selection
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
        if (isDropdownActive && e.ctrlKey || e.metaKey) {
          e.preventDefault();
          const index = parseInt(e.key) - 1;
          if (index < items.length) {
            const suggestion = items[index].getAttribute('data-suggestion');
            acceptSuggestion(suggestion);
          }
        }
        break;
    }
  });

  document.getElementById('input').addEventListener('keypress', async (e) => {
    if (e.key === 'Enter' && !document.getElementById('send').disabled) {
      // Hide auto-complete before sending
      hideAutoComplete();
      document.getElementById('send').click();
    }
  });

  // Hide suggestions when clicking outside
  document.addEventListener('click', (e) => {
    const inputContainer = document.getElementById('input-container');
    if (!inputContainer.contains(e.target)) {
      hideAutoComplete();
    }
  });

  document.getElementById('reset').addEventListener('click', async () => {
    if (currentThreadId && threads[currentThreadId]) {
      if (!confirm('Clear this conversation? This action cannot be undone.')) return;
      setInputEnabled(false);
      const newThreadId = await createOpenAIThread();
      threads[currentThreadId].threadId = newThreadId;
      threads[currentThreadId].chatHistory = [];
      threads[currentThreadId].lastAssistantMessageId = null;
      threads[currentThreadId].lastRunId = null;
      threads[currentThreadId].lastRunStatus = null;
      threads[currentThreadId].inputEnabled = true;
      // Clear last read timestamp for this thread
      delete lastReadTimestamps[currentThreadId];
      localStorage.setItem('lastReadTimestamps', JSON.stringify(lastReadTimestamps));
      persistThreads();
    }
    renderChat();
  });

  document.getElementById('settingsBtn').addEventListener('click', () => {
    document.getElementById('apiKeyInput').value = apiKey;
    document.getElementById('assistantIdInput').value = assistantId;
    document.getElementById('autoCompleteModelSelect').value = autoCompleteModel;
    document.getElementById('autoCompleteCheckbox').checked = autoCompleteEnabled;
    document.getElementById('renderMarkdownCheckbox').checked = renderMarkdown;
    document.getElementById('autoNamingCheckbox').checked = autoNaming;
    document.getElementById('notificationsCheckbox').checked = notificationsEnabled;
    const settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
    settingsModal.show();
  });

  document.getElementById('saveSettings').addEventListener('click', async () => {
    apiKey = document.getElementById('apiKeyInput').value.trim();
    assistantId = document.getElementById('assistantIdInput').value.trim();
    autoCompleteModel = document.getElementById('autoCompleteModelSelect').value;
    autoCompleteEnabled = document.getElementById('autoCompleteCheckbox').checked;
    renderMarkdown = document.getElementById('renderMarkdownCheckbox').checked;
    autoNaming = document.getElementById('autoNamingCheckbox').checked;
    notificationsEnabled = document.getElementById('notificationsCheckbox').checked;
    
    // Request notification permission if notifications are being enabled (but not for local files)
    if (notificationsEnabled && Notification.permission === 'default' && window.location.protocol !== 'file:') {
      await requestNotificationPermission();
    }
    
    localStorage.setItem('apiKey', apiKey);
    localStorage.setItem('assistantId', assistantId);
    localStorage.setItem('autoCompleteModel', autoCompleteModel);
    localStorage.setItem('autoCompleteEnabled', autoCompleteEnabled ? 'true' : 'false');
    localStorage.setItem('renderMarkdown', renderMarkdown ? 'true' : 'false');
    localStorage.setItem('autoNaming', autoNaming ? 'true' : 'false');
    localStorage.setItem('notificationsEnabled', notificationsEnabled ? 'true' : 'false');
    const settingsModal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
    settingsModal.hide();
  });

  // Make entire checkbox setting elements clickable
  document.querySelectorAll('.checkbox-setting').forEach(checkboxSetting => {
    checkboxSetting.addEventListener('click', (e) => {
      // Don't trigger if the actual checkbox was clicked (to avoid double toggle)
      if (e.target.type === 'checkbox') {
        return;
      }
      
      // Don't trigger if a label was clicked (let the label handle it naturally)
      if (e.target.tagName === 'LABEL') {
        return;
      }
      
      // Find the checkbox within this setting
      const checkbox = checkboxSetting.querySelector('input[type="checkbox"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        // Trigger change event to ensure any listeners are notified
        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
      }
    });
  });

  // Periodically check for new messages in all threads
  setInterval(async () => {
    for (const threadId of threadOrder) {
      const beforeCount = (threads[threadId]?.chatHistory || []).length;
      
      // Check current thread only if tab is not active (to avoid duplicate processing)
      if (threadId === currentThreadId && isTabActive) {
        continue; // Skip current thread if tab is active (it's already being processed in real-time)
      }
      
      await syncThreadWithOpenAI(threadId);
      const afterCount = (threads[threadId]?.chatHistory || []).length;

      // If new messages were found, update the thread list and show notifications
      if (afterCount > beforeCount) {
        renderThreadList();
        
        // Show notification for new assistant messages (for any thread when tab is not active)
        const thread = threads[threadId];
        if (thread && thread.chatHistory) {
          const newMessages = thread.chatHistory.slice(beforeCount);
          for (const message of newMessages) {
            if (message.sender === 'assistant') {
              showNotification(thread.displayName, message.text, threadId);
              break; // Only show one notification per thread per check
            }
          }
        }
      }
    }
  }, 5000); // Check every 5 seconds for better responsiveness

  // Initialize app
  cleanupGeneratingStates(); // Clean up any stuck states from previous session
  initializeSidebar();
  initializeSidebarResize();
  renderThreadList();
  renderChat();

  // Debug: Check if inline completion elements exist
  setTimeout(() => {
    const ghostElement = document.getElementById('input-ghost');
    const inputWrapper = document.querySelector('.input-wrapper');
    const input = document.getElementById('input');
    

  }, 1000);

  // Focus input box if there's a current thread and API is configured
  if (currentThreadId && threads[currentThreadId] && apiKey && assistantId) {
    focusInputBox(200);
  }

  // Don't auto-create a thread on load - wait for user to send a message
  if (!apiKey || !assistantId) {
    // Show a message in chat area if no API key is set
    const chat = document.getElementById('chat');
    chat.innerHTML = '<div class="welcome-message"><h2>Welcome to Ailo Support Assistant</h2><p>Please configure your API Key and Assistant ID in Settings to begin.</p></div>';
  }
</script>
</body>
</html>